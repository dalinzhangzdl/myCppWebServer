
# 服务器编程并发模型

当存在大量的客户请求，需要对应用进行高并发设计。并发模型主要有**多线程模型、多进程模型和事件驱动模型**。每种相应的并发模型都有其优缺点，针对实际的设计场景需要合理选择。

## 多线程模型

+ 多线程模型共享同一个进程空间，多线程之间的同步比较麻烦，且存在线程数量限制，对于一个进程空间而言，线程的数量存在上限。对于高并发设计场景，每接受一个客户连接需要创建一个子线程，利用子线程处理处理这个连接的请求。
+ 多线程模型不利于处理大并发模型。

## 多进程模型

+ 每接受一个客户连接就fork一个子进程，在子进程中处理连接的请求
+ 进程创建频繁系统开销大，存在最大进程数量限制，不利于处理高并发

## I/O复用模型

+ Linux下存在三种I/O复用模型， select poll 和 epoll
+ I/O复用使得程序能够同时监听多个文件描述符，但本身是阻塞的。
  + select监听用户感兴趣的文件描述符上的可读、可写和异常等事件。在指定时间内轮询一定数量的文件描述符。
  + poll使用pollfd注册可读、可写和异常事件，同select一样。在指定时间内轮询一定数量的文件描述符。
  + epoll将文件描述符上的事件注册到内核的一个事件表中，函数调用直接返回就绪的文件描述符个数，不需同select和poll一样，轮询所有的文件描述符。提高了效率
+ 基于I/O复用模型，结合non-blocking IO，以事件驱动和事件回调的方式实现业务逻辑，目前在高性能的网络程序中，使用的比较广泛的就是这种并发模型。
+ 结合线程池、进程池，同步队列，能够很好的处理高并发场景。

| 系统调用                       | select                                                       | poll                                                         | epoll                                                        |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 事件集合                       | 三个事件集合，可读、可写和异常事件。内核通过对这些参数的在线修改来反馈其中的就绪事件。每次调用select时需要重置这3个事件集合 | 统一处理所有事件类型。只需一个事件集参数，通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.events来反馈就绪的文件描述符。 | 内核通过一个事件表直接管理用户感兴趣的所有事件，因此每次调用epoll_wait时，无需反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件。 |
| 查找就绪文件描述符的时间复杂度 | O(N)  遍历所有的文件描述符查找就绪的文件描述符               | O(N)  遍历所有的文件描述符查找就绪的文件描述符               | epoll_wait直接返回就绪的文件描述符的数量 O(1)                |
| 最大支持文件描述符数           | 有最大值限制 1024                                            | 65535                                                        | 65535                                                        |
| 工作模式                       | LT                                                           | LT                                                           | 支持LT/ET两种模式 LT模式下epoll是一个高效的poll              |
| 内核实现和工作效率             | 轮询检测就绪事件。时间复杂度O(N)                             | 轮询检测就绪事件。时间复杂度O(N)                             | 采用回调方式来检测就绪事件，时间复杂度O(1)                   |



## 两种高效的事件处理模式

### Reactor模式

Reactor模式是指，主线程只负责监听文件描述符上是否有事件发生，当有事件发生时，将该事件分发到工作线程。主线程不做任何除监听之外其他实质性的工作。读写数据、接受新的连接、以及处理客户请求都在工作线程中完成。

**使用同步I/O模型实现的Reactor模式的工作流程是：**

1. 主线程往epoll内核事件表注册socket上的读就绪事件
2. 主线程调用epoll_wait等待socket上有数据可读
3. 当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。
4. 睡眠在请求队列上某个工作线程被唤醒，从socket读取数据，并处理客户请求，然后往epoll内核事件注册表中注册socket上的写就绪事件
5. 主线程调用epoll_wait等待socket可写
6. 当socket可写时，epoll_wait通知主线程。主线程将可写事件放入请求队列。
7. 睡眠在请求队列上的某个工作线程被唤醒，往socket上写入服务器处理客户请求的结果。

![reactor模式](C:/Users/USER/Desktop/myCppWebServer_final/readMe/img/Reactor.png)
![reactor高并发](C:/Users/USER/Desktop/myCppWebServer_final/readMe/img/Reactor1.png)

### Proactor模式

Proactor模式将所有的I/O操作都交给主线程和内核来处理，工作线程只负责业务逻辑处理，是异步I/O模型。

- 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。

- 事件分离器等待读取操作完成事件。

- 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，在Proactor中，应用程序需要传递缓存区。

- 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作

### reactor与proactor的区别

+ reactor是同步I/O， proactor是异步I/O
+ **reactor模式和proactor模式分离点在于worker thread的行为**；reactor模式中需要worker thread自己读取和写入数据，proactor模式，使用异步I/O，worker threads不需要进行实际的读写过程，由操作系统读写内核缓冲区到IO设备。

### 高效的并发处理模式

#### 半同步/半异步模式

同步是指程序按照顺序执行，异步是指程序的执行需要由系统事件来驱动，常见的系统事件包括中断、信号等。

半同步/半异步模式中，使用同步线程处理客户逻辑，异步线程用于处理I/O事件。异步线程监听到客户请求后，就将其封装成请求对象并插入到请求队列中；请求队列将通知工作在同步模式的工作线程来读取并处理该请求对象。

![半同步/半异步模式](C:/Users/USER/Desktop/myCppWebServer_final/readMe/img/半同步半异步.png)
![半同步/半反应堆模式](C:/Users/USER/Desktop/myCppWebServer_final/readMe/img/半同步半反应堆.png)
半同步/半反应堆使用的事件处理模式是Reactor模式，存在以下缺点与不足：

1. 主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，队列需要加锁保护，浪费一定的CPU时间。
2. 每个worker thread 在同一时间只能处理一个客户请求。高并发导致请求队列中堆积越来越多的任务对象，响应变慢。

![高效的半同步/半异步模式](C:/Users/USER/Desktop/myCppWebServer_final/readMe/img/高效的半同步半异步.png)
主线程只负责监听，socket连接由工作线程来管理。**每个线程都维持自己的事件循环**。

#### 领导者与追随者模式

领导者与追随者模式是多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件的一种模式。在任何时刻，程序都仅有一个领导者线程，负责监听IO事件。而其他线程都是追随者，他们休眠在线程池中等待成为新的领导者。若当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。此时新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件。

![leader/follower](C:/Users/USER/Desktop/myCppWebServer_final/readMe/img/leader and follower.png)

## 半同步半异步线程池设计

1. 多线程处理并发任务具备一定的优势。但大量的创建与消费线程，会消耗过多的系统资源，同时会增加线程上下文切换的开销。
2. 线程池技术可以解决上述问题。通过在系统中预先创建一下线程，当存在任务请求时从线程池中预先分配一个线程去单独处理任务。避免了频繁的线程创建与销毁，节省系统资源。
3. 多线程技术在多核处理器平台上可以实现真正的并行，提高效率

### 半同步半异步线程池结构

![img](.\img\线程池.png)

1. **同步服务层，**处理上层的任务请求，可以是并发，如socket连接，由于系统资源有限，所有的任务请求不可能同时得到满足。
2. **任务队列**，将同步服务层处理的任务请求加入至任务队列中，实现缓冲。
3. **异步服务层**，此处的异步是指同步服务层处理的请求不能得到立即处理。经过缓冲之后进入异步服务层，对任务队列中的任务执行处理。如采用线程池等。

**同步层负责将任务添加到任务队列中，异步服务层负责异步处理这些任务。**

![img](.\img\线程池2.png)

### 半同步半异步线程池实现

1. 多线程/进程并发的环境，需要一个多线程/进程安全的任务队列设计。
2. 异步服务层的高效处理，多线程/多进程—>线程池或进程池

因此需要解决同步任务队列设计核线程池设计即可。同步队列采用有限大小的缓冲区实现，基于生产者-消费者模型。使用智能指针管理线程池，避免资源泄漏。

#### 同步队列

```C++
template<typename T>
class SyncQueue {
private:
    std::list<T> m_queue;
    // 互斥访问
    std::mutex m_mutex;
    std::condition_variable_any m_notEmpty;
    std::condition_variable_any m_notFull;
    
    // 缓冲大小
    int m_maxSize;
    bool m_needStop;
public:
    // ....
}
```



#### 线程池实现

```C++
class ThreadPool{
public:
    using Task = std::function<void()>;   // 任务
    // ...
private:
    std::list<std::shared_ptr<std::thread>> m_threadgroup;   // 处理任务的线程组
    SyncQueue<Task> m_queue; // 同步队列
    atomic_bool m_running;   // 原子变量
    std::once_flag m_flag;   // 只调用一次
};
```

![img](.\img\线程池3.png)
